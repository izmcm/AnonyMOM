4c4
< // TODO: Implement whitelist
---
> // TODO: check for the problem of some messages being lost G_G
20d19
< 	"strings"
52c51
< var addr = flag.String("addr", "localhost:8082", "http service address")
---
> var addr = flag.String("addr", "localhost:8084", "http service address")
94d92
< 			// TODO: send to the user it's automatic generated token
101,102c99,100
< 
< 			for _, queueName := range r.Header["Subscriptions"] {
---
> 			// TODO: make the queue control access at here
> 			for _, q := range r.Header["Subscriptions"] {
105c103
< 				q, err := broker.Manager.GetQueueNamed(queueName)
---
> 				_, err := broker.Manager.GetQueueNamed(q)
107,108c105,106
< 					queuesNotAllowed.PushBack(queueName)
< 					fmt.Println("queue named", queueName, "doesn't exist!")
---
> 					queuesNotAllowed.PushBack(q)
> 					fmt.Println("queue named", q, "doesn't exist!")
112,120c110,111
< 				// Verify if the user can register in the queue before running it
< 				canSub := broker.Manager.CheckUserRights(host.ID, q, 0)
< 				if !canSub {
< 					queuesNotAllowed.PushBack(queueName)
< 					fmt.Println("queue named", queueName, "doesn't exist!")
< 					continue
< 				}
< 
< 				fmt.Println("subscribed to:", queueName)
---
> 				// TODO: verify if the user can register in the queue before running it
> 				fmt.Println("subscribed to:", q)
125c116
< 					if queueElement.Value.(string) == queueName {
---
> 					if queueElement.Value.(string) == q {
128c119
< 						fmt.Println("2: ", queueName)
---
> 						fmt.Println("2: ", q)
132d122
< 
133a124
> 				// TODO: checkup if we should look in the created queues
136,138c127,130
< 					fmt.Println("Registering listenner and channel for queue", queueName)
< 					numOfHostsInQueueChannel[queueName] = make(chan int)
< 					go broker.listenAndBroadcastQueue(queueName)
---
> 					fmt.Println("Registering listenner and channel for queue", q)
> 					numOfHostsInQueueChannel[q] = make(chan int)
> 					// go broker.listenAndBroadcastQueue(q, numOfHostsInQueueChannel[q])
> 					go broker.listenAndBroadcastQueue(q)
141,144c133,137
< 				host.Subscriptions.PushBack(queueName)
< 				fmt.Println("Prev in queue <", queueName, ">:", numOfHostsInQueue[queueName])
< 				numOfHostsInQueue[queueName] += 1
< 				fmt.Println("Hosts in queue <", queueName, ">:", numOfHostsInQueue[queueName])
---
> 				host.Subscriptions.PushBack(q)
> 				// WARNING: checkup if the user has a 0 in the first input
> 				fmt.Println("Prev in queue <", q, ">:", numOfHostsInQueue[q])
> 				numOfHostsInQueue[q] += 1
> 				fmt.Println("Hosts in queue <", q, ">:", numOfHostsInQueue[q])
178,180c171
< 				// queue := queue.AnonyQueue{Name: data["queue"][0], Owner: data["token"][0], Type: tp}
< 				queue := queue.New(data["queue"][0], data["token"][0], tp, 0)
< 				_, err := broker.Manager.GetQueueNamed(queue.Name)
---
> 				queue := queue.AnonyQueue{Name: data["queue"][0], Owner: data["token"][0], Type: tp}
181a173
> 				_, err := broker.Manager.GetQueueNamed(queue.Name)
210,247c202
< 		}
< 
< 		if action == "BlackList" && data["List"] != nil {
< 			q, err := broker.Manager.GetQueueNamed(data["queue"][0])
< 			if err != nil {
< 				fmt.Println("Error blacklisting users\n")
< 				w.Write([]byte("Error blacklisting users\n"))
< 				return
< 			}
< 
< 			if q.Owner != data["token"][0] {
< 				fmt.Println("You don't own this queue\n")
< 				fmt.Println("the owner is", q.Owner, "not you,", data["token"][0])
< 				w.Write([]byte("You don't own this queue\n"))
< 				return
< 			}
< 
< 			if q.Type != 1 {
< 				fmt.Println("Queue doesn't support blacklist\n")
< 				w.Write([]byte("Queue doesn't support blacklist\n"))
< 				return
< 			}
< 
< 			fmt.Println("--------------------")
< 			for _, user := range data["List"] {
< 				fmt.Println("Blacklisting user", user)
< 				q.BlackList.PushBack(user)
< 			}
< 			fmt.Println("starting serialization")
< 			// TODO: new goroutine here
< 			q.SerializeQueue()
< 			fmt.Println("serialization finished")
< 			fmt.Println("--------------------")
< 
< 		}
< 
< 		// Request not processed
< 		if action == "" {
---
> 		} else {
325,336c280
< 
< 			newMessageBytes := []byte(message)
< 			// set maximum TCP network packet size (1460 bytes)
< 			bytesSize := len([]byte(message))
< 			if bytesSize < 1460 {
< 				trash := strings.Repeat("0", 1459-bytesSize)
< 				newMessage := message + ";" + trash
< 				newMessageBytes = []byte(newMessage)
< 			}
< 
< 			err := c.WriteMessage(websocket.TextMessage, newMessageBytes)
< 
---
> 			err := c.WriteMessage(websocket.TextMessage, []byte(message))
378c322
< 	http.ListenAndServe(":8082", nil)
---
> 	http.ListenAndServe(":8084", nil)
